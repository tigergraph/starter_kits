CREATE QUERY repeated_user (VERTEX<User> receiver) for GRAPH AntiFraud syntax v2 {
 /*
   Given a money receiver, this query is to discover whether there exists relationships among 
   those people who have sent money to this receiver. 
   
    1) Starting from a receiver "receiver", find all of her transactions receiving money.
    2) Find all the senders from the transactions collected in step 1)
    3) start from the senders in step 2), go as far as 8 steps from each sender, 
       find all the senders that are connected to other senders by a path made of 
       Device_Token, Payment_Instrument, and Users.
    4) Output all the transactions started by the senders found in step 3) and received by the input user.

    Sample input:
    receiver: Recommend to use 1223 as input. Or, try integer between 1 and 500.
  */
  
  SumAccum<INT> @sum_message_receive;
  OrAccum<BOOL> @is_s, @is_repeated;
  MaxAccum<VERTEX> @max;
  MinAccum<VERTEX> @min;
  SetAccum<VERTEX> @@linked_joint_set;
  SetAccum<EDGE> @@edge_set;
 
  start (ANY) = {receiver};
  // Prep 1: Get all transactions the receiver get money from.
  transactions = SELECT t 
      FROM start:s-(User_Receive_Transaction>:e)-:t
      ACCUM @@edge_set += e
      POST-ACCUM t.@is_s += TRUE;

  // Prep 2: Get all senders related to the above transactions(Prep 1) .
  start = SELECT t 
      FROM transactions:s-(<User_Transfer_Transaction:e)-:t
      ACCUM @@edge_set += e
      POST-ACCUM 
          t.@sum_message_receive += 1,
          t.@is_s += TRUE,
          t.@max = t,
          t.@min = t;

  // 1. Traverse 8 step from the senders(Prep 2). min/max is used to find joint node
  WHILE (start.size() > 0) LIMIT 8 DO
      start = SELECT t 
          FROM start:s-((User_to_Device|User_to_Payment):e)-:t
          WHERE t.@sum_message_receive == 0
          ACCUM
              t.@sum_message_receive += 1,
              t.@min += s.@min,
              t.@max += s.@max
          POST-ACCUM
              // When received message from different source
              CASE WHEN 
                t.@sum_message_receive > 1 AND t.@min != t.@max 
              THEN
                @@linked_joint_set += t
              END;   
  END;

  start = {@@linked_joint_set};

  // 2. Trace back to the source senders from the vertexes(1) that joint multiple paths
  WHILE (start.size() > 0) DO
      start = SELECT t 
          FROM start:s-((User_to_Device|User_to_Payment):e)-:t
          WHERE t.@sum_message_receive != 0
          ACCUM @@edge_set += e
          POST-ACCUM
              s.@sum_message_receive = 0
          POST-ACCUM
              CASE WHEN 
                t.@is_s 
              THEN
                t.@is_repeated += TRUE
              END;
  END;
  
  // 3. Get the transactions to output
  transactions = SELECT s 
      FROM transactions:s-(<User_Transfer_Transaction:e)-:t
      WHERE t.@is_repeated == TRUE
      ACCUM @@edge_set += e;
  
  // Output the result
  PRINT transactions [transactions.amount];
  PRINT @@edge_set;
}